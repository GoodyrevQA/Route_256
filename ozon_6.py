# region нсловия
'''
Реализуйте элемент функциональности простейшего терминала.
Изначально терминал содержит одну пустую строку, в начале которой находится курсор.
Ваша программа должна уметь обрабатывать последовательность символов (строку ввода).
Обработка символа зависит от его значения:

- Строчная буква латинского алфавита или цифра обозначает, что соответствующий символ вставляется в положение курсора.
Курсор сдвигается на позицию после вставленного символа.

∙ Буквы L и R
обозначают нажатия стрелок влево и вправо. Они перемещают курсор на одну позицию влево или вправо.
Если в соответствующем направлении нет символа, то операция игнорируется. Заметьте, что курсор в любом случае
остаётся в той же строке.

∙ Буквы U и D обозначают нажатия стрелок вверх и вниз. Они перемещают курсор на одну позицию вверх или вниз.
Если в соответствующем направлении нет строки, то операция игнорируется.
Если строка есть, но в ней нужная позиция не существует, то курсор встаёт в конец строки.

∙ Буквы B и E обозначают нажатия клавиш Home и End. Они перемещают курсор в начало или в конец текущей строки.

∙ Буква N обозначает нажатие клавиши Enter — происходит вставка новой строки.
Если курсор находился не в конце текущей строки, то она разрывается, и часть после курсора переносится в новую строку.
Курсор после этой операции стоит в начале новой строки.
Вы можете представлять себе, что эмулируете последовательность нажатий в простейшем текстовом редакторе,
в котором курсор занимает позицию между двумя символами строки (или находится в начале или конце строки).

Например, если строка ввода имеет вид 
otLLLrRuEe256LLLN, то в результате получится две строки:

∙ route
∙ 256

Промоделируйте последовательность действий и выведите результат.
'''
# endregion

def common(char, el1, el2, mtrx):
    global x
    mtrx[el2].insert(el1, char)
    x +=1

def L(el1, el2, mtrx):
    global x
    if el1 > 0:
        x -= 1

def R(el1, el2, mtrx):
    global x
    if el1 < len(mtrx[el2]):
        x += 1

def U(el1, el2, mtrx):
    global x
    global y
    if el2 > 0:
        y -= 1
        if len(mtrx[el2 - 1]) < el1:
            x = len(mtrx[el2 - 1])

def D(el1, el2, mtrx):
    global x
    global y
    if el2 + 1 < len(mtrx):
        y += 1
        if el1 > len(mtrx[el2 + 1]):
            x = len(mtrx[el2 + 1])

def B(el1, el2, mtrx):
    global x
    x = 0

def E(el1, el2, mtrx):
    global x
    x = len(mtrx[el2])

def N(el1, el2, mtrx):
    global x
    global y
    mtrx.insert(el2 + 1, [])
    if el1 < len(mtrx[el2]):
        for elem in mtrx[el2][el1:][::-1]:
            mtrx[el2 + 1].insert(0, elem)
        del mtrx[el2][el1:]
    y += 1
    x = 0

funcs = {'L': L, 'R': R, 'U': U, 'D': D, 'N': N, 'E': E, 'B': B}

n = int(input())
ml = []
for _ in range(n):
    x, y = 0, 0
    mtrx = [[]]

    for char in input():
        if char not in funcs.keys():
            common(char, x, y, mtrx)
        else:
            funcs[char](x, y, mtrx)
    
    for line in mtrx:
        # if not line:
        #     continue
        s = ''.join(line)
        ml.append(s)
    ml.append('-')
   
print(*ml, sep='\n')




